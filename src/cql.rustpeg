use cql::*;

#[pub]
cql_statement -> ParsedCqlStatement
    = select_statement / insert_statement / delete_statement / update_statement

select_statement -> ParsedCqlStatement
    = select
      fields:fields_or_star
      from table:table
      where_clauses:where_clauses?
      order_by:order_by_clause?
      limit_clause?
    {
        let s = SelectStatement::new(fields,
                                     table,
                                     where_clauses,
                                     order_by);
        ParsedCqlStatement::Select(s)
    }

insert_statement -> ParsedCqlStatement
    = "insert" into  table:table __ "(" fields:fields ")" values
        "(" placeholder ++ ","  ")" __ if_not_exists?
        using_clause?
      {
          let i = InsertStatement::new(fields, table);
          ParsedCqlStatement::Insert(i)
      }

delete_statement -> ParsedCqlStatement
    = delete from table:table
      where_clauses
      {
        let d = DeleteStatement::new(table);
        ParsedCqlStatement::Delete(d)
      }

update_statement -> ParsedCqlStatement
    = update table:table
        using_clause?
        set assignment ++ comma
        where_clauses if_clause?
        {
            let u = UpdateStatement::new(table);
            ParsedCqlStatement::Update(u)
        }

#[pub]
where_clauses -> Vec<Predicate> = where __ predicates __
    { Vec::new() }

where_clause = where __ predicate __

predicates = __ predicate ++ and __

#[pub]
predicate -> Predicate
    = field:field op:op placeholder
    { Predicate::new(field, op) }

op -> String
    = ('=' / '<' / '>' / '<=' / '>=' / "contains"i / "contains key"i)
    {  match_str.to_string() }


plus = "+" __
minus = "-" __
comma = __ "," __
delete = "delete" __
placeholder = __ "?" __
and = __ "and"i __
from = __ "from"i __
where = "where"i  __

star -> Fields
    = __ "*" __ { Fields::All }

select =  "select"i __

field -> String
    = __ [a-zA-Z0-9]+ __ { match_str.to_string() }

values = __ "values"i __
update = "update"i __
set = __ "set"i __
into = __ "into"i __
using = "using"i __
if_not_exists = __ "if"i __ "not"i __ "exists" __
timestamp = "timestamp"i __
ttl = "ttl"i __
eq = "=" __
lbracket = "{" __
rbracket = "}" __
if = "if"i __
colon = ":" __

if_clause = if if_condition ++ "and"
if_condition = (field eq placeholder) /
                (field "[" field "]" eq placeholder)

#[pub]
using_clause = using using_options ++ "and"i __

using_options = timestamp_clause / ttl_clause
timestamp_clause = timestamp int
ttl_clause = ttl int

order_by_clause -> String
    = "order" __ "by" __ field __ order_direction?
    { match_str.to_string() }

asc = "asc"i
desc = "desc"i
order_direction = asc / desc

#[pub]
assignment = (field eq placeholder) / counter_op

#[pub]
counter_op = field eq field (plus / minus) (int / placeholder)

#[pub]
map_literal = lbracket (field colon placeholder ++ comma) rbracket

#[pub]
fields -> Fields
    = fields:(field ++ comma)
    { Fields::Named(fields) }


#[pub]
fields_or_star -> Fields
    = fields / star

table -> String
    = [a-zA-Z]+ __  { match_str.to_string() }

limit = "limit"i __
int = [1-9][0-9]* __

limit_clause = __ limit int __

__ = (whitespace / eol)*

whitespace
  = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}] // \v\f removed

eol
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"
